#!/usr/bin/python3
import argparse
import os
import subprocess

from kolibri.core.content.utils.paths import get_content_dir_path
from kolibri.utils.options import update_options_file
from kolibri.utils.conf import OPTIONS
from kolibri.utils.conf import KOLIBRI_HOME
from six.moves.urllib.parse import urljoin

# read the config file options
port = OPTIONS["Deployment"]['HTTP_PORT']
path_prefix = OPTIONS['Deployment']['URL_PATH_PREFIX']

if path_prefix != '/':
    path_prefix = '/' + path_prefix

STATIC_URL = urljoin(path_prefix, 'static/')
STATIC_ROOT = os.path.join(KOLIBRI_HOME, "static")


def start_debconf_dialog():
    """
    Auxiliar function to start a dialog with debconf database
    """
    args = ['debconf-communicate', '-fnoninteractive', 'kolibri-server']
    dccomm = subprocess.Popen(
        args, stdin=subprocess.PIPE, stdout=subprocess.PIPE, close_fds=True, universal_newlines=True
    )
    return dccomm


def stop_debconf_dialog(dccomm):
    """
    Auxiliar function to end a dialog with debconf database
    """
    dccomm.stdin.write('STOP\n')
    dccomm.stdin.flush()


def get_debconf_port():
    """
    Reads from debconf database the TCP port that has been chosen
    while installing the kolibri-server package to run the webserver
    """
    dccomm = start_debconf_dialog()

    dccomm.stdin.write("GET kolibri-server/port\n")
    dccomm.stdin.flush()
    resp = dccomm.stdout.readline().rstrip('\n')
    if ' ' in resp:
        status, port = resp.split(' ', 1)
    else:
        status, port = resp, ''
    if status != '0':
        raise Exception(resp)
    stop_debconf_dialog(dccomm)
    return port


def set_debconf_port(port):
    """
    Sets the port kolibri uses in debconf database, to be used by future
    reconfigurations or upgrades of the kolibri-server package
    """
    dccomm = start_debconf_dialog()
    dccomm.stdin.write("SET kolibri-server/port {}\n".format(port))
    dccomm.stdin.flush()
    stop_debconf_dialog(dccomm)
    return port


def set_port(port):
    """
    Modify Kolibri options to set the TCP port the server will listen on
    """
    update_options_file("Deployment", "HTTP_PORT", port, KOLIBRI_HOME)


def disable_cherrypy():
    """
    Disables internal kolibri web server.
    Kolibri will only run background tasks.
    Web must be provided by an external server, usually uwsgi + nginx
    """
    update_options_file('Server', "CHERRYPY_START", False, KOLIBRI_HOME)


def save_nginx_conf_port(port, nginx_conf=None):
    """
     Adds the port for nginx to run to an existing config file.
    """

    if nginx_conf is None:
        nginx_conf = os.path.join(KOLIBRI_HOME, "nginx.conf")

    # If a port is already in the file, let's not add a new one:
    with open(nginx_conf, 'r') as nginx_conf_file:
        data_configs = nginx_conf_file.read()
    if "listen" in data_configs:
        return

    configuration = "\nlisten {};\n".format(port)

    with open(nginx_conf, 'a') as nginx_conf_file:
        nginx_conf_file.write(configuration)


def save_nginx_conf_include(static_root, nginx_conf=None):
    """
    Automatically writes the dynamic Nginx configuration include from Kolibri
    configuration.

    This function is called from within the DJANGO_SETTINGS_MODULE after it
    has defined STATIC_ROOT.

    The nginx configuration snippet is loaded with in the main Nginx
    configuration which contains::

        include /path/to/.kolibri/nginx.conf;

    Note that because we cannot load django.conf.settings from this module
    (because Django settings depend on Kolibri conf), we have a sort of
    circular issue with STATIC_ROOT. We cannot fetch settings.STATIC_ROOT
    unless we start writing the Nginx configuration elsewhere during the load
    order.
    """

    if nginx_conf is None:
        nginx_conf = os.path.join(KOLIBRI_HOME, "nginx.conf")

    with open(nginx_conf, 'w') as nginx_conf_file:
        configuration = (
            "# This file is maintained AUTOMATICALLY and will be overwritten\n"
            "#\n"
            "# Do not edit this file. If you are using the kolibri-server"
            "package,\n"
            "# please write custom configurations in /etc/kolibri/nginx.d/\n"
            "\n"
            "location /static {{\n"
            "    alias  {static_dir};\n"
            "}}\n"
            "location /content {{\n"
            "    alias  {content_dir}/;\n"
            "}}\n"
        ).format(static_dir=static_root, content_dir=get_content_dir_path())
        nginx_conf_file.write(configuration)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="Tool to configure kolibri-server")
    parser.add_argument(
        "-r",
        "--reconfigure",
        type=bool,
        required=False,
        default=False,
        help="Used to configure the system when installing/reconfiguring kolibri-server package",
    )
    parser.add_argument(
        "-p",
        "--debconfport",
        required=False,
        default="",
        help="Initial port to be used when installing/reconfiguring kolibri-server package",
    )
    args = parser.parse_args()
    if args.reconfigure:  # To be executed only when installing/reconfiguring the Debian package
        debconf_port = args.debconfport if args.debconfport else get_debconf_port()
        disable_cherrypy()
        set_port(debconf_port)
    else:
        disable_cherrypy()
        save_nginx_conf_include(STATIC_ROOT)
        save_nginx_conf_port(port)
        # Let's update debconf, just in case the user has changed the port in options.ini:
        set_debconf_port(port)
